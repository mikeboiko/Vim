"    ____      ____  ____      ______  _______        _____         _____
"   |    |    |    ||    |    |      \/       \   ___|\    \    ___|\    \
"   |    |    |    ||    |   /          /\     \ |    |\    \  /    /\    \
"   |    |    |    ||    |  /     /\   / /\     ||    | |    ||    |  |    |
"   |    |    |    ||    | /     /\ \_/ / /    /||    |/____/ |    |  |____|
"   |    |    |    ||    ||     |  \|_|/ /    / ||    |\    \ |    |   ____
"   |\    \  /    /||    ||     |       |    |  ||    | |    ||    |  |    |
"   | \ ___\/___ / ||____||\____\       |____|  /|____| |____||\ ___\/    /|
"    \ |   ||   | / |    || |    |      |    | / |    | |    || |   /____/ |
"     \|___||___|/  |____| \|____|      |____|/  |____| |____| \|___|    | /
"       \(    )/      \(      \(          )/       \(     )/     \( |____|/
"        '    '        '       '          '         '     '       '   )/
"                                                                     '

" TODOs {{{1
" TODO-MB [180408] - Get better plugin manager. It should work with offline computer. vim-plug? Help with map conflicts.
" TODO-MB [180407] - Replace dispatch with better plugin, perhaps asyncrun.vim - Test on Linux
" TODO-MB [180315] - Checkout ale - asynchronous linting. Then get prettier for js/vue.
" TODO-MB [180416] - Make my <leader>p into an action map so I could apply it to any text object. This way I could get rid of <leader><leader> maybe?
" TODO-MB [180407] - Consider changing fold marker to $$$ so it doesn't mess with bracket interpretting/closing. I tested the problem with vue.
" TODO-MB [180122] - Get equalprgs for commonly used languages. Or get vim-prettier equivalent for python and c#. Test with fold markers.
" TODO-MB [180206] - gd should open folds after going to definition. Try in C# project
" TODO-MB [180210] - Write command to use ag to find code samples in all my git repos quickly. Use file type option and -i (case-insensitive). fa = find all code. fn = find notes.
" TODO-MB [180213] - Re-write RepoGrep function to use the silver searcher and include fold text like FindFunc
" TODO-MB [180117] - Create macro to add/remove fold text (functions/classes/etc)
" TODO-MB [180311] - Get rid of prompt in TrimSpaces where I have to hit a. Just do it everytime.
" TODO-MB [180312] - Create a way to save b:start and b:startapp. This should check if I'm on my development computer and load the variables automatically on file load.

" TODO-MB [171119] - Function snippets should insert themselves in the proper locaiton
" TODO-MB [171101] - Fix QuickFix list regex that formats |
" TODO-MB [170814] - Create skeleton file for markdown/others

" Constants {{{1

" Max Number of Records to show in QF/Location Lists
let g:maxQFlistRecords = 8
let g:qfListHeight = 5

" Data entry prompts
let g:promptCommentText = 'Comment Text: '

" Fold marker string used through vimrc file without messing up folding
let g:fold_marker_string = '{'. '{'. '{'

" Functions {{{1
function! BufDo(command) " {{{2
    " Just like bufdo, but restore the current buffer when done.
    let currBuff=bufnr("%")
    execute 'bufdo ' . a:command
    execute 'buffer ' . currBuff
endfunction

function! CloseQuickFixWindow() " {{{2
    " If the window is quickfix, proceed
    if &buftype=="quickfix"
        " If this window is last on screen quit without warning
        if winbufnr(2) == -1
            quit!
        endif
    endif
endfunction

function! PromptAndComment(inline_comment, prompt_text, comment_prefix) " {{{2
    " Add inline comment and align with other inline comments

    " Prompt user for comment text
    let prompt = UserInput(a:prompt_text)

    " Abort the rest of the function if the user hit escape
    if (prompt == '') | return | endif

    " Temporarily disable auto-pairs wrapping so the comment delimiter doesn't repeat
    let b:autopairs_enabled = 0

    " Either inline comment or comment above current line
    let insert_command = (a:inline_comment) ? 'A ' : 'O'

    " Prepare execution script for adding commented line
    let exe_string = 'normal ' . insert_command . b:NERDCommenterDelims['left'] . ' ' . a:comment_prefix . prompt

    " Add inline comment (add right delimiter if it exists)
    if (b:NERDCommenterDelims['right'] != '')
        let exe_string .= ' ' . b:NERDCommenterDelims['right']
    endif

    " Add commented line to document
    exe exe_string

    " Re-enable auto-pairs
    let b:autopairs_enabled = 1

    " TODO-MB [180123] - The alignment needs to be fixed so it doesn't align the first row if it's a comment
    " " Prepare string with escaped special characters for Tab plugin
    " let escapedCommaDelimiter = escape(b:NERDCommenterDelims['left'], '/')
    " Align comments in paragraph
    " exe "Tab /" . escapedCommaDelimiter

endfunction

function! CodeCleanUP() " {{{2
    " Macros to clean up code

    " Put a space after comment delimiter if it doesn't exist already
    let escapedCommaDelimiter = escape(b:NERDCommenterDelims['left'], '/')
    exe '%s/' . escapedCommaDelimiter . '\(\s\)\@!/' . escapedCommaDelimiter .' /g'

endfunction

function! EditCommonFile(filename) " {{{2
    " Open file in new teb
    let current_filename = expand('%:t')
    let openfilestring = 'tabedit ' . a:filename
    silent exec openfilestring
    " Close the blank buffer
    if (current_filename == '')
        tabprev
        bd
    endif
endfunction

function! FindFunc(...) " {{{2

    " Move cursor to next pattern match
    if (a:2 == 'next')
        call search(a:1)
        FoldOpen
    endif

    " Save search string into window local var
    let w:searchStr=a:1

    " Record initial line number into "z
    let @z=' | '.line('.')

    " Clear quickfix list
    lexpr []

    " Put Results into QuickFix Window
    " Remove ':' from each line because it messes up the caddexpr filename/line num
    silent execute 'g/'.a:1.'/laddexpr expand("%")  . ":" . line(".") . ":" . GetLastFoldString() . substitute(getline("."), ":", "", "g")'

    " Prepare location list height - minimum or record count and max allowable limit
    let w:locListHeight = min([ g:maxQFlistRecords, len(getloclist(0)) ])

    " If there are no matched records, return
    if !w:locListHeight
        lclose
        return
    endif

    " Open Loc List and limit the record number
    execute 'bot ' . w:locListHeight . 'lopen'

    " Update search register
    let @/=a:1

    " Find initial line in QuickFix list
    call search(@z)

    " Jump to that record
    exe "normal \<CR>"

    " Go to proper column number (rather than the beginning of the line)
    GoToMatchedColumn
endfunction

" FoldText{{{2
function! GetFoldStrings() " {{{3
    " Make the status string a list of all the folds
    " Iterate through each fold level and add fold string to list
    let foldStringList = []
    let i = 1
    while i <= foldlevel(".")
        " Append string to list
        call add(foldStringList, FormatFoldString(GetLastFoldLineNum(i)))
        let i += 1
    endwhile

    " Add each fold line to status string
    let statusString = ""
    for i in foldStringList
        let statusString = statusString."|".i
    endfor

    return statusString."|"
endfunction

function! GetLastFoldString() " {{{3
    " Get the text of the last fold
    return FormatFoldString(GetLastFoldLineNum(foldlevel(".")))."|"
endfunction

function! GetLastFoldLineNum(foldLvl) " {{{3
    " Get the line number of last Fold
    " Only search current line for fold marker
    let line = search(g:fold_marker_string.a:foldLvl,"n",line("."))
    " Search backwards for fold marker
    if (line==0)
        let line = search(g:fold_marker_string.a:foldLvl,"bn")
    endif
    return line
endfunction

function! FormatFoldString(lineNum) " {{{3
    " Format fold string so it looks neat
    " Get the line string of the current fold and remove special chars
    let line = getline(a:lineNum)
    " Remove programming language specific words
    let line = RemoveFiletypeSpecific(line)
    " Remove special (comment related) characters and extra spaces
    let line = RemoveSpecialCharacters(line)
    return line
endfunction

function! RemoveSpecialCharacters(line) " {{{3
    " Remove special (comment related) characters and extra spaces
    " Characters: " # ; /* */ // <!-- --> g:fold_marker_string
    " Remove fold marker string and comment characters
    let text = substitute(a:line, g:fold_marker_string.'\d\=\|'.b:NERDCommenterDelims['left'].'\|'.b:NERDCommenterDelims['right'], '', 'g')
    " Replace 2 or more spaces with a single space
    let text = substitute(text, ' \{2,}', ' ', 'g')
    " Remove leading and trailing spaces
    let text = substitute(text, '^\s*\|\s*$', '', 'g')
    " Remove text between () in functions
    let text = substitute(text, '(\(.*\)', '()', 'g')
    " Add nice padding
    return " ".text." "
endfunction

function! RemoveFiletypeSpecific(line) " {{{3
    " Remove programming language specific words
    let text = a:line
    if (&ft=='python')
        let text = substitute(a:line, '\<def\>\|\<class\>', '', 'g')
    elseif  (&ft=='cs')
        let text = substitute(a:line, '\<static\>\|\<int\>\|\<float\>\|\<void\>\|\<string\>\|\<bool\>\|\<private\>\|\<public\>\s', '', 'g')
    elseif  (&ft=='vim')
        let text = substitute(a:line, '\<function\>!\s', '', 'g')
    elseif  (&ft=='markdown')
        let text = substitute(a:line, '#', '', 'g')
    elseif  (&ft=='javascript')
        let text = substitute(a:line, '=\|{\s', '', 'g')
    endif
    return text
endfunction
" FontSize() {{{2
if has("unix")
    function! FontSizePlus ()
        let l:gf_size_whole = matchstr(&guifont, '\( \)\@<=\d\+$')
        let l:gf_size_whole = l:gf_size_whole + 1
        let l:new_font_size = ' '.l:gf_size_whole
        let &guifont = substitute(&guifont, ' \d\+$', l:new_font_size, '')
    endfunction

    function! FontSizeMinus ()
        let l:gf_size_whole = matchstr(&guifont, '\( \)\@<=\d\+$')
        let l:gf_size_whole = l:gf_size_whole - 1
        let l:new_font_size = ' '.l:gf_size_whole
        let &guifont = substitute(&guifont, ' \d\+$', l:new_font_size, '')
    endfunction
else
    function! FontSizePlus ()
        let l:gf_size_whole = matchstr(&guifont, '\(:h\)\@<=\d\+$')
        let l:gf_size_whole = l:gf_size_whole + 1
        let l:new_font_size = ':h'.l:gf_size_whole
        let &guifont = substitute(&guifont, ':h\d\+$', l:new_font_size, '')
    endfunction

    function! FontSizeMinus ()
        let l:gf_size_whole = matchstr(&guifont, '\(:h\)\@<=\d\+$')
        let l:gf_size_whole = l:gf_size_whole - 1
        let l:new_font_size = ':h'.l:gf_size_whole
        let &guifont = substitute(&guifont, ':h\d\+$', l:new_font_size, '')
    endfunction
endif

function! GetBufferList() " {{{2
    " load all current buffers into a list
    redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction

function! GetTODOs() " {{{2
    " TODO [171103] - Add current file ONLY option
    " Binary files that can be ignored
    set wildignore+=*.jpg,*.docx,*.xlsm,*.mp4
    " Seacrch the CWD to find all of your current TODOs
    vimgrep /TODO-MB \[\d\{6}]/ **/* **/.* | cw 5
    " Un-ignore the binary files
    set wildignore-=*.jpg,*.docx,*.xlsm,*.mp4
endfunction

function! GitAddCommitPush() " {{{2
    " Git - add all, commit and push

    " Prompt user for commit text
    let prompt = UserInput('Commit Message: ')

    " Abort the rest of the function if the user hit escape
    if (prompt == '') | return | endif

    if has("unix") " Linux
        let exe_string = 'bash ~/Documents/GitRepos/Linux/git/gap'
    else " Windows
        " let exe_string = 'powershell ~/Documents/GitRepos/Linux/git/gap.ps1'
        let exe_string = '"C:\Program Files\Git\usr\bin\bash.exe" ~/Documents/GitRepos/Linux/git/gap'
        " I'm targeting WSL here
        " let exe_string = 'bash /mnt/c/Users/Mike/Documents/GitRepos/Linux/git/gap'
    endif

    exe 'silent Start ' . exe_string . ' ' . shellescape(prompt)

endfunction

function! ToggleList(bufname, pfx) " {{{2
    " Toggle QuickFix/Location List, don't change focus
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx.'close')
            return
        endif
    endfor

    " Set orignal window
    let winnr = winnr()

    " Location List
    if a:pfx == 'l'
        " Nicer error message than original
        if len(getloclist(0)) == 0
            echohl ErrorMsg
            echo "Location List is Empty."
            return
        endif
        " Open window with minimum height
        exec 'bot '. w:locListHeight .a:pfx.'open'
        " QuickFix List
    elseif a:pfx == 'c'
        " Open window with minimum height
        exec 'top '. g:qfListHeight .a:pfx.'open'
    endif

    " Change focus back to the orignal window
    if winnr() != winnr
        wincmd p
    endif

endfunction

function! RepoGrep(...) " {{{2
    " TODO-MB [171106] - Make this function work with multi-word arguments
    " Fugitive Ggrep Wrapper
    " Load QuickFix window with grep results
    exe 'silent Ggrep! -i ' . a:1
    let g:qfListHeight = min([ g:maxQFlistRecords, len(getqflist()) ])
    exe 'top ' . g:qfListHeight . ' copen'
endfunction

function! SetCurrentWorkingDirectory() " {{{2
    " A standalone function to set the working directory to the project's root, or
    " to the parent directory of the current file if a root can't be found:
    let cph = expand('%:p:h', 1)
    if cph =~ '^.\+://' | retu | en
    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
        let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
        if wd != '' | let &acd = 0 | brea | en
    endfo
    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
endfunction

function! ShowSpaces(...) " {{{2
    " Show trailing white spaces
    let @/='\v(\s+$)|( +\ze\t)'
    let oldhlsearch=&hlsearch
    if !a:0
        let &hlsearch=!&hlsearch
    else
        let &hlsearch=a:1
    end
    return oldhlsearch
endfunction

function! TrimSpaces() range " {{{2
    " Trim trailing white spaces
    let oldhlsearch=ShowSpaces(1)
    execute a:firstline.",".a:lastline."substitute ///gec"
    let &hlsearch=oldhlsearch
    execute "normal! `m"
endfunction

function! UserInput(prompt) " {{{2
    " Get a string input from the user
    " Get input from user
    call inputsave()
    let reply=input(a:prompt)
    call inputrestore()
    " Return the user's reply
    return l:reply
endfunction

" Snippets{{{2
function! SnipClass() " {{{3
    if &filetype == "php"
        execute "normal! oclass  {\<CR>public function __construct() {\<CR>}\<CR>}\<ESC>kkk^t{" | startinsert
    endif
endfunction

function! SnipComment() " {{{3
    execute "read $CODE/vim/Snippets/SectionComment.txt"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! jj"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! k"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! $l" | startinsert!
endfunction

function! SnipFunction() " {{{3
    if &filetype == "vim"
        execute "normal! ofunction \<CR>endfunction\<ESC>k" | startinsert!

    elseif &filetype == "sh"
        execute "normal! ofunction \<CR>{\<CR>}\<ESC>kk" | startinsert!
    endif
endfunction

function! SnipHeader() " {{{3
    execute "read $CODE/vim/Snippets/Header.txt"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! kddjjjpk"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! k"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! k"
    execute "cal NERDComment(0,\"toggle\")"
    execute "normal! $l" | startinsert!
endfunction

function! SnipIf() " {{{3
    if &filetype == "php"
        execute "normal! o// IF\<CR>\<ESC>^Diif () {\<CR>}\<ESC>kf)" | startinsert
    elseif &filetype == "vim"
        execute "normal! o\" IF\<CR>\<ESC>^Diif \<CR>endif\<ESC>k" | startinsert!
    endif
endfunction

function! SnipLog() " {{{3
    " Log variable to console for debugging
    if &filetype == "vue" || &filetype == "javascript"
        let log_string = "console.log()"
    elseif &filetype == "python"
        let log_string = "print()"
    else
        let log_string = "echo  "
    endif
    execute "normal o" . log_string | startinsert
endfunction

function! WinDo(command) " {{{2
    " Just like windo, but restore the current window when done.
    let currwin=winnr()
    execute 'windo ' . a:command
    execute currwin . 'wincmd w'
endfunction

function! WrapFold(foldlevel) range " {{{2
    " Create a fold on the current line(s)
    let foldlevel = a:foldlevel
    if l:foldlevel == 0
        let foldlevel = foldlevel(line('.'))
        if l:foldlevel == 0
            let foldlevel = 1
        endif
    endif

    " User entered fold name
    let prompt = UserInput('Fold Text: ')

    " Abort the rest of the function if the user hit escape
    if (prompt == '') | return | endif

    " Prevent folding on seperate levels
    let foldLevelFirst = foldlevel(a:firstline)
    let foldLevelLast = foldlevel(a:lastline)
    if len(getline(a:firstline, a:lastline)) == 0 || l:foldLevelFirst != l:foldLevelLast
        return '' " No lines selected
    endif

    " Wrap selection with fold
    execute 'normal! mm'
    execute 'normal! ' . a:firstline . 'GO' . prompt . ' ' . g:fold_marker_string . l:foldlevel . "\<ESC>:call NERDComment(0,'toggle')\<CR>"
    execute 'normal! `m'
endfunction
" Commands {{{1
" Bufdo {{{2

" Just like bufdo, but restore the current buffer when done.
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)

" Windo {{{2

" Just like windo, but restore the current window when done.
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" Just like Windo, but disable all autocommands for super fast processing.
com! -nargs=+ -complete=command Windofast noautocmd call WinDo(<q-args>)

" CtrlpToggle {{{2

" Toggle between CtrlP MRU/Project Files
command! ToggleCtrlP if (g:ctrlp_cmd == 'CtrlPMRU') | let g:ctrlp_cmd = 'CtrlP' | echo 'CtrlP in Project Files Mode' | else | let g:ctrlp_cmd = 'CtrlPMRU' | echo 'CtrlP in MRU Files Mode' | endif

" FindLocal {{{2
" Search for string in current file and put results in Location window
command! -nargs=+ -complete=command FindLocal
            \| try | silent call FindFunc(<q-args>, 'next') | catch | endtry | set hls

" FoldOpen {{{2

" Suppress errors when no fold exists
" The catch part of the command prevents an error that would move the cursor when there are no folds in the file
command! FoldOpen let save_cursor = getcurpos() | try | silent foldopen! | catch | call setpos('.', save_cursor) | endtry

" QuickFix/Location List Next {{{2
" Wrap around after hitting first/last record
command! Cnext try | cnext | catch | cfirst | catch | endtry
command! Cprev try | cprev | catch | clast | catch | endtry
command! Lnext try | lnext | catch | lfirst | catch | endtry
command! Lprev try | lprev | catch | llast | catch | endtry

" GoToMatchedColumn {{{2
" Since the QF list isn't populated with col numbers, this function allows you to jump to the proper column.
command! GoToMatchedColumn exe "normal b" | let @/=w:searchStr | call search(@/) | set hls

" FindGlobal {{{2
" Search for string in current repo and put results in QuickFix window
command! -nargs=+ -complete=command FindGlobal
            \| try | call RepoGrep(<q-args>) | catch | endtry

" Show and Trim Spaces {{{2
command! -bar -nargs=? ShowSpaces call ShowSpaces(<args>)
command! -bar -nargs=0 -range=% TrimSpaces <line1>,<line2>call TrimSpaces()

" Replace ^M Line endings {{{2

" Useful when converting from DOS to Unix line endings
command! ReplaceMwithBlank try | %s/\r$// | catch | endtry

" Useful when converting from DOS to Unix line endings
command! ReplaceMwithNewLine try | %s/\r/\r/ | catch | endtry

" SpellToggle {{{2
command! SpellToggle if (&spell == 0) | setlocal spell | echo 'Spell-check enabled' | else | setlocal nospell | echo 'Spell-check disabled' | endif

" Editor Settings{{{1
" Display{{{2

" 256 color
set t_Co=256

" Preferred background
set background=dark

" Preferred color scheme
if has("gui_running")
    colorscheme desert
else
    colorscheme elflord
endif

" Set GVIM Font
" To select form availbale fonts :set guifont=*
if has("unix")
    set guifont=Ubuntu\ Mono\ 13
else
    set guifont=Consolas:h12
endif

" Display line number for current line
set number

" Display relative line number along the left hand side
set relativenumber

" Start scrolling <x> lines before window border
set scrolloff=8

" Visual auto complete for command menu
set wildmenu

" Show command in bottom bar
set showcmd

" Do not redraw during operations such as macro
set lazyredraw

" Don't wrap/line break in the middle of a word
set linebreak

" Always display the status line even if only one window is displayed
set laststatus=2

" Display hidden char
let g:display_hidden = "hidden"

" Change the text that is displayed while in a fold
set foldtext=v:folddashes.FormatFoldString(v:foldstart)

" Functionality{{{2
" General{{{3

" Optimize GVim
if has('GUI')
    " Disable annoying error bell sounds
    autocmd GUIEnter * set vb t_vb=

    " Open GVim in Maximized mode
    if has("unix")
        autocmd GUIEnter * call system('wmctrl -i -b add,maximized_vert,maximized_horz -r '.v:windowid)
    else
        autocmd GUIEnter * simalt ~x
    endif

    " Remove Menubar and Toolbar from GVIM
    set guioptions -=m
    set guioptions -=T
endif

" General settings required for highlighting
syntax on

" Enable plug-ins for indentation
filetype plugin indent on

" Eliminate command windows escape delay
set timeoutlen=500 ttimeoutlen=0

" Backspace over auto indent, line breaks, start of insert
set backspace=indent,eol,start

" Remove vi compatibility
set nocompatible

" Update when idle for 1000 msec (default is 4000 msec)
set updatetime=1000

" Virtual editing, position cursor where there is are no characters (all modes)
set virtualedit=all

" Ignore file patterns globally
set wildignore+=*.swp

" Standard Encoding
set encoding=utf8

" TODO-MB [180314] - I don't think this is required
" Buffer should be modifable (GV-Vim needs this)
" set modifiable

" No .swp backup files
set noswapfile

" Use linux shard clipboard in VIM
if has("unix")
    set clipboard=unnamedplus
    " Use windows shard clipboard in VIM
else
    set clipboard=unnamed
endif

" TODO-MB [180213] - Remove after confirming that the new functionality is better
" Automatically change current directory when new file is opened
set autochdir
" Automatically change current directory to project root
" autocmd BufEnter * call SetCurrentWorkingDirectory()

" Enable Vim to check for modelines throughout your files
" best practice to keep them at the top or the bottom of the file
set modeline
" Number of modelines to be checked, if set to zero then modeline checking
" will be disabled
set modelines=5

" Don't add comment automatically on new line
au FileType * setlocal formatoptions-=cro

" Spelling
set spellfile=$HOME/OneDrive/Software/Settings/en.utf-8.add

" Have Vim jump to the last position when reopening a file
if has("autocmd")
    au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
                \| exe "normal! g'\"" | endif
endif

" Folding{{{3
set foldenable
set foldlevelstart=0
set foldnestmax=10
set foldmethod=marker
set foldignore=
set foldlevel=2

" Indenting/Tabs{{{3
" Do smart auto indenting when starting a new line
set autoindent
set smartindent

" Set tab width
set tabstop=4
set softtabstop=4
set shiftwidth=4

" Use spaces instead of tabs
set expandtab
" Delete spaces like tabs
set smarttab

" Searching{{{3
" Search as characters are entered
set incsearch
" Highlight search
set hlsearch
" Ignore case of given search term
set ignorecase
" Only search for matching capitals when they are used
set smartcase

" QuickFix/Location {{{3

" TODO-MB [171030] - The second regex expression will match every second |
" Align QuickFix List (only first 3 '|')
au BufReadPost QuickFix,Location setlocal modifiable
            \| silent exe 'Tab /^.\{-}\zs|'
            \| silent exe 'Tab /\(.\{-}\zs|\)\{2}'
            \| silent exe 'Tab /\(.\{-}\zs|\)\{3}'
            \| setlocal nowrap
            \| setlocal norelativenumber
            \| setlocal cursorline
            \| nnoremap <buffer> <CR> <CR>:FoldOpen<CR>
            \| setlocal nomodifiable
" \| nnoremap <buffer> <CR> <CR>:FoldOpen<CR>:GoToMatchedColumn<CR>

" Close QuickFix/Location lists automatically when it's the last window in current tab
au BufEnter * call CloseQuickFixWindow()

" Undo Files {{{3
" Let's save undo info!
if !isdirectory($HOME."/vimfiles")
    call mkdir($HOME."/vimfiles", "", 0770)
endif
if !isdirectory($HOME."/vimfiles/undo-dir")
    call mkdir($HOME."/vimfiles/undo-dir", "", 0700)
endif
set undodir=~/vimfiles/undo-dir
set undofile

" Plugins{{{2
" Custom Languages {{{3

" SEBOL:
au BufRead,BufNewFile *.sebol setfiletype sebol

" Pathogen{{{3
" Pathogen source all Vim bundles found in ~/.vim/bundle
execute pathogen#infect()

" AirLine{{{3
let g:airline_section_a = '%f'
let g:airline_section_c = '%{GetFoldStrings()}'

" Emmet HTML/JS {{{3
let g:user_emmet_leader_key = '<c-b>'

" CtrlP {{{3
" Fuzzy file/buffer/tag open

" Since I'm toggling CtrlP functionality, I remapped my own <c-p> command
let g:ctrlp_map = ''

" Most recent files is default
let g:ctrlp_cmd = 'CtrlPMRU'

" Use filename instead of full path for searching
let g:ctrlp_by_filename = 1

noremap <silent> <c-l> <nop>
noremap <silent> <c-h> <nop>

" Remap hotkeys
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
            \ 'ToggleType(1)':        ['<c-f>'],
            \ 'ToggleType(-1)':       ['<c-b>'],
            \ }


" NerdCommenter{{{3

" NerdCommenter add a space after comment
let g:NERDSpaceDelims=1

" Remove extra spaces when uncommenting
let g:NERDRemoveExtraSpaces=1

" Custom comment delimiters
let g:NERDCustomDelimiters = {
            \ 'python': { 'left': '#', 'right': '' },
            \ 'dosbatch': { 'left': 'REM', 'right': '' },
            \ 'sebol': { 'left': '!', 'right': '' }
            \ }


" NERDTree{{{3
" Close NERDTree when opening file
let NERDTreeQuitOnOpen = 1
" Show hidden files by default
let NERDTreeShowHidden = 1
" Enable Bookmarks by default
let NERDTreeShowBookmarks = 1
" Line Numbers
let NERDTreeShowLineNumbers=1

" Syntastic{{{3
" TODO-MB [170506] - Add Python Virtual Environments and make pylint work for
" Python 2 and 3
"let g:syntastic_always_populate_loc_list = 1
"let g:syntastic_auto_loc_list = 1
"let g:syntastic_check_on_open = 1
"let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = { 'mode': 'passive', 'active_filetypes': [],'passive_filetypes': [] }
" TODO-MB [170524] - Find a cleaner way to use syntastic
nnoremap <leader>cp :SyntasticCheck<CR>
" Vim-Indent-Guides {{{3
" Indent Guides default is on
let g:indent_guides_enable_on_vim_startup = 1

" The Silver Searcher {{{3
if executable('ag')
    " Use ag instead of grep (performance increase)
    set grepprg=ag\ --nogroup\ --nocolor

    " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

    " ag is fast enough that CtrlP doesn't need to cache
    " let g:ctrlp_use_caching = 0
endif

" Vim-QF {{{3
" let g:qf_mapping_ack_style = 1

" YouCompleteMe{{{3
" Close preview window after completion
let g:ycm_autoclose_preview_window_after_completion=1

nnoremap <space>fi :YcmCompleter FixIt<CR>

" Language/Project Specific{{{1
" Comma/Pipe/Tab Seperated Values{{{2
" autocmd BufReadPost *.tsv,*.csv,*.psv execute 'Tabularize /,'
autocmd BufReadPost *.csv setlocal nowrap
autocmd BufReadPost *.psv setlocal nowrap
autocmd BufReadPost *.tsv setlocal nowrap
" autocmd BufReadPost *.csv 1sp
" autocmd BufReadPost *.psv 1sp
" autocmd BufReadPost *.tsv 1sp
" HTML/js/css/Vue {{{2
autocmd FileType html,javascript,json,vue,css,scss setlocal shiftwidth=2 tabstop=2

" Vue {{{2

" Fix the syntax highlighting that randomly stops
autocmd FileType vue syntax sync fromstart

" Speed up vim when in vue files
let g:vue_disable_pre_processors=1

" NERDCommenter fix
" En error occured when putting this code into a seperate vim.vue file

let g:ft = ''

function! NERDCommenter_before()
    if &ft == 'vue'
        let g:ft = 'vue'
        let stack = synstack(line('.'), col('.'))
        if len(stack) > 0
            let syn = synIDattr((stack)[0], 'name')
            if len(syn) > 0
                exe 'setf ' . substitute(tolower(syn), '^vue_', '', '')
            endif
        endif
    endif
endfunction

function! NERDCommenter_after()
    if g:ft == 'vue'
        setf vue
        let g:ft = ''
    endif
endfunction

" Mappings{{{1
" Leader key {{{2
let mapleader="\<space>"

" Add colon/comma to EOL {{{2

" Colon
inoremap ;; <esc>mzA;<esc>`z
nnoremap <leader>a; mzA;<esc>`z

" Comma
inoremap ,, <esc>mzA,<esc>`z
nnoremap <leader>a, mzA,<esc>`z

" Auto-Indent {{{2
" Indent entire file and return to current line
nnoremap <leader>ai mpgg=G'p

" Close all location lists {{{2

nnoremap <leader>ac :Windofast lclose<CR>:cclose<CR>

" Command Line {{{2

" Get into command history
nnoremap q; q:

" Paste
cmap <c-v> <c-r>+

" Comment {{{2

" Inline Comment
nnoremap <leader>cii :call PromptAndComment(1, 'Comment Text: ', '')<CR>

" Inline comments with folds
map <leader>ci1 <plug>NERDCommenterAppend<c-r>=g:fold_marker_string<CR>1<ESC>
map <leader>ci2 <plug>NERDCommenterAppend<c-r>=g:fold_marker_string<CR>2<ESC>
map <leader>ci3 <plug>NERDCommenterAppend<c-r>=g:fold_marker_string<CR>3<ESC>
map <leader>ci4 <plug>NERDCommenterAppend<c-r>=g:fold_marker_string<CR>4<ESC>

" Comment, Yank and Paste
nnoremap <leader>cy "zyy:silent execute "cal NERDComment('n',\"comment\")"<CR>"zp
vnoremap <leader>cy "zY:<c-u>silent execute "cal NERDComment('v',\"comment\")"<CR>}"zP

" Comment/Uncomment Paragraph
map <leader>cp vip<plug>NERDCommenterYank
map <leader>cu vip<plug>NERDCommenterUncomment

" Convert Line Endings {{{2

" Convert to Dos
nnoremap <leader>ctd mz:e ++ff=dos<CR>`z

" Convert to Mac
nnoremap <leader>ctm mz:e ++ff=mac<CR>`z

" Convert to Unix
nnoremap <leader>ctu mz:e ++ff=unix<CR>:ReplaceMwithBlank<CR>`z

" CtrlP {{{2

" Either run CtrlP or CtrPMRU
" This can be toggled with the ToggleCtrlP command
nmap <c-p> :execute g:ctrlp_cmd<CR>

" Cycle through Auto-Suggestions {{{2
inoremap <c-j> <c-n>
inoremap <c-k> <c-p>

" Dump Register
nnoremap <leader><space> "z
nnoremap <leader>p "adiwP

" Edit Common Files {{{2
nnoremap <leader>ev :call EditCommonFile('$CODE/vim/.myvimrc')<CR>
nnoremap <leader>eac :call EditCommonFile('$CODE/Windows/AHK/Common.ahk')<CR>

" End/Beginning of Line {{{2
nnoremap <silent> H ^
nnoremap <silent> L $
vnoremap <silent> H ^
vnoremap <silent> L $
omap H ^
omap L $

" Enter/CR Key {{{2

" Disable in normal mode
nnoremap <CR> <nop>

" Escape Key {{{2

" Disable Highlighting
nnoremap <esc> :noh<esc>

" NERDTree{{{2
nnoremap <leader>on :NERDTreeFind<CR>

" Find - Local {{{2

" Find string in current file
nnoremap <leader>fl :FindLocal<space>

" Find word under cursor
map <leader>fw "xyiw:call FindFunc("\\<".@x."\\>", '')<CR>

" TODO-MB [171019] - Finish up the find tag function
" map <leader>ft :exe "FindLocal \\<".tagbar#currenttag("[%s]","")."\\>"

" Find - Global {{{2

" Find in current Git Repo and put reslts in QuickFix window
nnoremap <leader>fg :FindGlobal<space>

" Ggrep word under cursor
map <leader>gw "xyiw:exe "FindGlobal ".@x<CR>

" Yank highlighted text into "z and Ggrep
vnoremap <c-g> "xy:FindGlobal <c-r>x<CR>

" Folding {{{2

" Fold Everything except for the current section
nnoremap <leader>zf zMzvzz

" Create Folds
noremap <silent> <leader>zz :call WrapFold(v:count)<CR>
noremap <silent> <leader>zj :call WrapFold(foldlevel(line(".")) + 1)<CR>
noremap <silent> <leader>zk :call WrapFold(foldlevel(line(".")) - 1)<CR>

" Font Size Bigger/Smaller {{{2

" Font Hotkeys
if has("gui_running")
    nmap <S-F6> :call FontSizeMinus()<CR>
    nmap <F6> :call FontSizePlus()<CR>
endif

" Git {{{2

" Fugitive remappings
nnoremap <leader>gd :Gdiff<Space>
nnoremap <leader>gs :Gstatus<CR>

" Git history
nnoremap <leader>gh :Git! hist<CR>

" Git - add all, commit and push
nnoremap <leader>gap :silent call GitAddCommitPush()<CR>

" Help {{{2

" Pull up help for word under cursor in a new tab
noremap <leader>hh :execute "tab h " . expand("<cword>")<cr>

" Insert Mode Escape {{{2
inoremap <silent> <enter> <esc>

" Marks {{{2
" Jump to proper column when using marks
nnoremap ' `

" New blank line {{{2
" Add blank line after current line
nnoremap <leader>aj :<CR>mzo<Esc>`z:<CR>

" Add blank line before current line
nnoremap <leader>ak :<CR>mzO<Esc>`z:<CR>

" Add blank line before and after current line
nnoremap <leader>al :<CR>mzO<Esc>jo<Esc>`z:<CR>

" Restore Enter key functionality for command history window
autocmd CmdwinEnter * nnoremap <buffer> <CR> <CR>

" Navigation {{{2
" Do not automatically adjust for line wrapping
nnoremap <expr> j v:count ? 'j' : 'gj'
nnoremap <expr> k v:count ? 'k' : 'gk'

" Scrolling{{{2

" Scroll Up
nnoremap K 5k
" Scroll Down
nnoremap J 5j

" Open File/Folder {{{2

" Explorer
nnoremap <leader>oe :silent !explorer .<CR>

" Chrome
nnoremap <leader>oc :silent !"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" ".\<c-r>%"<CR>

" Double Commander
nnoremap <leader>od :Start -wait=never "C:\Program Files\Double Commander\doublecmd.exe" %:p:h<CR>

" Go to Definition{{{2

" Preview definition in split window and focus on fold
map gp :sp<CR>gdzMzvzz

" Go to definition and focus on fold
map gd gdzMzvzz

" Rename Tag {{{2

" Copy word under cursor into "a and paste into new buffer
nnoremap <leader>rt mz"ayiw:1sp wordRenamingBuffer<CR>"aP

" After edits, press enter, the original word is renamed globally
" The search is case sensitive because of I in .../gI
" Press escape to cancel
au BufWinEnter,BufEnter wordRenamingBuffer nnoremap <buffer> <Esc> :q!<CR>
au BufWinEnter,BufEnter wordRenamingBuffer nnoremap <buffer> <Enter>
            \ b"byiw:q!<CR>:%s/\<<c-r>a\>/<c-r>b/gI<CR>`z

" QuickFix/Location Lists {{{2

" Go to next/previous search result
" nnoremap <leader>zf zMzvzz
nnoremap <C-f> :Lnext<CR>:GoToMatchedColumn<CR>:FoldOpen<CR>
nnoremap <C-d> :Lprev<CR>:GoToMatchedColumn<CR>:FoldOpen<CR>
nnoremap <C-r> :Cnext<CR>:FoldOpen<CR>
nnoremap <C-e> :Cprev<CR>:FoldOpen<CR>

nmap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>q :call ToggleList("Quickfix List", 'c')<CR>

" Quit {{{2

" Close location list then quit
nnoremap <c-w> :lclose<CR>:q<CR>

" A hack to close the Fugitive Plugin window with <c-w>
nmap gf gf

" Exit command history window q: or q/ with <c-w>
au CmdwinEnter * nnoremap <buffer> <c-w> :q!<CR>

" Save Buffer {{{2

nnoremap <c-s> :w<CR>

" Snippets {{{2
" nnoremap <leader>snc :call SnipClass()<CR>
nnoremap <leader>snc :call SnipComment()<CR>
nnoremap <leader>snf :call SnipFunction()<CR>
nnoremap <leader>snh :call SnipHeader()<CR>
nnoremap <leader>sni :call SnipIf()<CR>
nnoremap <leader>snl :call SnipLog()<CR>

" Show and Trim Spaces {{{2

nnoremap <leader>ts mm:TrimSpaces<CR>

" Sorting {{{2
nnoremap <leader>so vip:sort<CR>

" Source {{{2
nnoremap <leader>sv :w<CR>:so $HOME/.vimrc<CR>

" Spell Toggle {{{2
" Toggle the spelling on/off
nnoremap <leader>st :SpellToggle<CR>

" TagBar {{{2
nnoremap <leader>tb ::TagbarOpenAutoClose<CR>

" Run Scripts {{{2

" Initialize Start argument. Can't be null
au BufEnter,BufCreate * call StartArgInitialize()
function! StartArgInitialize()
    if !exists('b:start')
        let b:start = ''
    endif
    if !exists('b:startapp')
        let b:startapp = ''
    endif
endfunction

" Run Script Asynchronously
nnoremap <leader>rr :wa<CR>:silent exe "Start ".b:startapp." ".@%." "b:start<CR>
" For example, to use bash: let b:startapp = '"C:\Program Files\Git\git-bash.exe"'

" Run Python
nnoremap <leader>rsp :wa<CR>:silent exe "Start py -2 ".@%." "b:start<CR>
nnoremap <leader>rp :wa<CR>:exe "Start py -2 ".@%." "b:start<CR>

" Tabs {{{2

" Open current file in new tab
nnoremap <c-t> mm:tabe <c-r>%<CR>`m

" Toggle tabs
nnoremap + gt
nnoremap _ gT

" TODOs {{{2

" Add new TODO above current line
let todoPrefix = 'TODO-MB [' . strftime('%y%m%d') . '] - '
nnoremap <silent> <leader>ti :call PromptAndComment(0, 'TODO: ', todoPrefix)<CR>

" Find all TODOs
nnoremap <silent> <leader>tf :call GetTODOs()<CR>

" Window {{{2

" Use Alt+h/j/k/l to move between windows
nnoremap <C-j> <C-W>j
nnoremap <C-k> <C-W>k
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l

" Resize
nnoremap <leader>wgv :<C-U>exec "vertical resize +".v:count1<CR>
nnoremap <leader>wgh :<C-U>exec "resize +".v:count1<CR>

" Windows Style Commands {{{2

" Redo
nnoremap <c-y> <c-r>
inoremap <c-y> <Esc><C-r>

" Paste from clipboard
nnoremap <c-v> o<esc>P
inoremap <c-v> <c-r>+

" Yank {{{2
" Yank till the end of the line
nnoremap Y y$

" Yank all
nnoremap <leader>ya mzggyG`z

" Templates {{{1
" Load template based on current file extension (:help template)
augroup templates
    " Remove ALL auto commands for the current group
    autocmd!
    " Expand file extension and search templates placing content at top of file
    autocmd BufNewFile *.* silent! execute '0r $CODE/vim/templates/skeleton.'.expand("<afile>:e")
    " Substitute equations between the VIM_EVAL and END_EVAL equations
    autocmd BufNewFile * %substitute#\[:VIM_EVAL:\]\(.\{-\}\)\[:END_EVAL:\]#\=eval(submatch(1))#ge
augroup END

" Temporary{{{1
" SQL Assist Mapping {{{2
autocmd BufReadPost *.sql let @z = expand('%:r')
"autocmd BufReadPost *.sql nnoremap <leader>rms :silent !python Clone.py & cd C:/Users/Mike/.bin & python sqlShowResults.py <c-r>z<CR>
autocmd BufReadPost *.sql nnoremap <leader>rms :silent !python Analyze.py & cd C:/Users/Mike/.bin & python sqlShowResults.py<CR>
autocmd BufReadPost *.sql nnoremap <F5> :silent !python Analyze.py & cd C:/Users/Mike/.bin & python sqlShowResults.py<CR>

